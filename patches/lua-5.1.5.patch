diff --git a/ldblib.c b/ldblib.c
index 6a07237b..2b5de5b3 100644
--- a/ldblib.c
+++ b/ldblib.c
@@ -136,6 +136,9 @@ static int db_getinfo (lua_State *L) {
     treatstackoption(L, L1, "activelines");
   if (strchr(options, 'f'))
     treatstackoption(L, L1, "func");
+  if (strchr(options, 'C')) {
+    settabss(L, "str1", ar.str1);
+  }
   return 1;  /* return table */
 }
     
@@ -205,7 +208,7 @@ static const char KEY_HOOK = 'h';
 
 static void hookf (lua_State *L, lua_Debug *ar) {
   static const char *const hooknames[] =
-    {"call", "return", "line", "count", "tail return"};
+    {"call", "return", "line", "count", "tail return", "edge", "data"};
   lua_pushlightuserdata(L, (void *)&KEY_HOOK);
   lua_rawget(L, LUA_REGISTRYINDEX);
   lua_pushlightuserdata(L, L);
@@ -226,6 +229,8 @@ static int makemask (const char *smask, int count) {
   if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
   if (strchr(smask, 'r')) mask |= LUA_MASKRET;
   if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (strchr(smask, 'e')) mask |= LUA_MASKEDGE;
+  if (strchr(smask, 'd')) mask |= LUA_MASKDATA;
   if (count > 0) mask |= LUA_MASKCOUNT;
   return mask;
 }
@@ -236,6 +241,8 @@ static char *unmakemask (int mask, char *smask) {
   if (mask & LUA_MASKCALL) smask[i++] = 'c';
   if (mask & LUA_MASKRET) smask[i++] = 'r';
   if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  if (mask & LUA_MASKEDGE) smask[i++] = 'e';
+  if (mask & LUA_MASKDATA) smask[i++] = 'd';
   smask[i] = '\0';
   return smask;
 }
diff --git a/ldebug.c b/ldebug.c
index 4fa42ac9..2c5a1b06 100644
--- a/ldebug.c
+++ b/ldebug.c
@@ -219,6 +219,12 @@ static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
         }
         break;
       }
+      case 'C': {
+        if (ci && isLua(ci)) {
+          ar->str1 = trace_cmp(L);
+        }
+        break;
+      }
       case 'L':
       case 'f':  /* handled by lua_getinfo */
         break;
diff --git a/ldo.c b/ldo.c
index d7a587e9..0834e01a 100644
--- a/ldo.c
+++ b/ldo.c
@@ -204,7 +204,6 @@ void luaD_callhook (lua_State *L, int event, int line) {
   }
 }
 
-
 static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
   int i;
   int nfixargs = p->numparams;
diff --git a/lua.c b/lua.c
index b8cf32ed..085f81b7 100644
--- a/lua.c
+++ b/lua.c
@@ -35,7 +35,7 @@ static void lstop (lua_State *L, lua_Debug *ar) {
 static void laction (int i) {
   signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                               terminate process (default action) */
-  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT | LUA_MASKEDGE | LUA_MASKDATA, 1);
 }
 
 
diff --git a/lua.h b/lua.h
index fd1e46e5..398733fb 100644
--- a/lua.h
+++ b/lua.h
@@ -310,6 +310,8 @@ LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
 #define LUA_HOOKLINE	2
 #define LUA_HOOKCOUNT	3
 #define LUA_HOOKTAILRET 4
+#define LUA_HOOKEDGE    5
+#define LUA_HOOKDATA    6
 
 
 /*
@@ -319,6 +321,8 @@ LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
 #define LUA_MASKRET	(1 << LUA_HOOKRET)
 #define LUA_MASKLINE	(1 << LUA_HOOKLINE)
 #define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+#define LUA_MASKEDGE	(1 << LUA_HOOKEDGE)
+#define LUA_MASKDATA	(1 << LUA_HOOKDATA)
 
 typedef struct lua_Debug lua_Debug;  /* activation record */
 
@@ -351,6 +355,7 @@ struct lua_Debug {
   int linedefined;	/* (S) */
   int lastlinedefined;	/* (S) */
   char short_src[LUA_IDSIZE]; /* (S) */
+  char *str1;	/* (C) */
   /* private part */
   int i_ci;  /* active function */
 };
diff --git a/lvm.c b/lvm.c
index 6c92567f..bf50d384 100644
--- a/lvm.c
+++ b/lvm.c
@@ -76,6 +76,31 @@ static void traceexec (lua_State *L, const Instruction *pc) {
     if (npc == 0 || pc <= oldpc || newline != getline(p, pcRel(oldpc, p)))
       luaD_callhook(L, LUA_HOOKLINE, newline);
   }
+
+  Proto *p = ci_func(L->ci)->l.p;
+  OpCode opcode;
+  int npc = pcRel(pc, p);
+  int newline = getline(p, npc);
+  /* Instruction *i = L->savedpc; */
+  /* Instruction i = *(L->savedpc - 1); */
+  /* const Instruction *oldpc = L->savedpc; */
+  opcode = GET_OPCODE(*pc);
+  if ((mask & LUA_MASKDATA) &&
+      (opcode == OP_JMP)) {
+      luaD_callhook(L, LUA_HOOKDATA, newline); /* call data hook */
+  }
+  if ((mask & LUA_MASKEDGE) &&
+      ((opcode == OP_EQ)        ||
+       (opcode == OP_LT)        ||
+       (opcode == OP_LE)        ||
+       (opcode == OP_TEST)      ||
+       (opcode == OP_TESTSET)   ||
+       (opcode == OP_CALL)      ||
+       (opcode == OP_TAILCALL)  ||
+       (opcode == OP_TFORLOOP)  ||
+       (opcode == OP_FORLOOP))) {
+      luaD_callhook(L, LUA_HOOKEDGE, newline); /* call edge hook */
+  }
 }
 
 
@@ -368,7 +393,36 @@ static void Arith (lua_State *L, StkId ra, const TValue *rb,
           Protect(Arith(L, ra, rb, rc, tm)); \
       }
 
+char *trace_cmp(lua_State *L) {
+  Instruction i;
+  OpCode opcode;
+  LClosure *cl;
+  TValue *k, *rb;
+
+  /* CallInfo *nci = ci->previous; */
+  i = *(L->savedpc - 1);
+  opcode = GET_OPCODE(i);
+  printf("OPCODE: %s\n", luaP_opnames[opcode]);
+  if ((opcode != OP_EQ)  &&
+      (opcode != OP_LT)  &&
+      (opcode != OP_LE)) {
+    return NULL;
+  }
+
+  i = *(L->savedpc - 2);
+  printf("OPCODE: %s\n", luaP_opnames[GET_OPCODE(i)]);
+  if (!(GET_OPCODE(i) == OP_LOADK))
+    return NULL;
 
+  cl = &clvalue(L->ci->func)->l;
+  k = cl->p->k;
+  rb = k + GETARG_Bx(i);
+  if (!ttisstring(rb))
+    return NULL;
+
+  /* return getstr(tsvalue(rb)); */
+  return NULL;
+}
 
 void luaV_execute (lua_State *L, int nexeccalls) {
   LClosure *cl;
diff --git a/lvm.h b/lvm.h
index adca8cdd..e65fbc32 100644
--- a/lvm.h
+++ b/lvm.h
@@ -21,6 +21,7 @@
 #define equalobj(L,o1,o2) \
 	(ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))
 
+char *trace_cmp(lua_State *L);
 
 LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
 LUAI_FUNC int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2);
