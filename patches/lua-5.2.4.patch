diff --git a/ldblib.c b/ldblib.c
index c0226945..473eaeea 100644
--- a/ldblib.c
+++ b/ldblib.c
@@ -155,6 +155,9 @@ static int db_getinfo (lua_State *L) {
     treatstackoption(L, L1, "activelines");
   if (strchr(options, 'f'))
     treatstackoption(L, L1, "func");
+  if (strchr(options, 'C')) {
+    settabss(L, "str1", ar.str1);
+  }
   return 1;  /* return table */
 }
 
@@ -258,7 +261,7 @@ static int db_upvaluejoin (lua_State *L) {
 
 static void hookf (lua_State *L, lua_Debug *ar) {
   static const char *const hooknames[] =
-    {"call", "return", "line", "count", "tail call"};
+    {"call", "return", "line", "count", "tail call", "edge", "data"};
   gethooktable(L);
   lua_pushthread(L);
   lua_rawget(L, -2);
@@ -278,6 +281,8 @@ static int makemask (const char *smask, int count) {
   if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
   if (strchr(smask, 'r')) mask |= LUA_MASKRET;
   if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (strchr(smask, 'e')) mask |= LUA_MASKEDGE;
+  if (strchr(smask, 'd')) mask |= LUA_MASKDATA;
   if (count > 0) mask |= LUA_MASKCOUNT;
   return mask;
 }
@@ -288,6 +293,8 @@ static char *unmakemask (int mask, char *smask) {
   if (mask & LUA_MASKCALL) smask[i++] = 'c';
   if (mask & LUA_MASKRET) smask[i++] = 'r';
   if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  if (mask & LUA_MASKEDGE) smask[i++] = 'e';
+  if (mask & LUA_MASKDATA) smask[i++] = 'd';
   smask[i] = '\0';
   return smask;
 }
diff --git a/ldebug.c b/ldebug.c
index a585075c..7435acc6 100644
--- a/ldebug.c
+++ b/ldebug.c
@@ -253,6 +253,12 @@ static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
         }
         break;
       }
+      case 'C': {
+        if (ci && isLua(ci)) {
+          ar->str1 = trace_cmp(ci);
+        }
+        break;
+      }
       case 'L':
       case 'f':  /* handled by lua_getinfo */
         break;
diff --git a/ldo.c b/ldo.c
index 7ab9312f..e7b2ada6 100644
--- a/ldo.c
+++ b/ldo.c
@@ -363,7 +363,7 @@ int luaD_poscall (lua_State *L, StkId firstResult) {
   StkId res;
   int wanted, i;
   CallInfo *ci = L->ci;
-  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
+  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE | LUA_MASKEDGE | LUA_MASKDATA)) {
     if (L->hookmask & LUA_MASKRET) {
       ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
       luaD_hook(L, LUA_HOOKRET, -1);
diff --git a/lua.c b/lua.c
index 6a007129..37464c02 100644
--- a/lua.c
+++ b/lua.c
@@ -101,7 +101,7 @@ static void lstop (lua_State *L, lua_Debug *ar) {
 static void laction (int i) {
   signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                               terminate process (default action) */
-  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT | LUA_MASKEDGE | LUA_MASKDATA, 1);
 }
 
 
diff --git a/lua.h b/lua.h
index bfb6bfd7..6a4b54da 100644
--- a/lua.h
+++ b/lua.h
@@ -362,6 +362,8 @@ LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
 #define LUA_HOOKLINE	2
 #define LUA_HOOKCOUNT	3
 #define LUA_HOOKTAILCALL 4
+#define LUA_HOOKEDGE    5
+#define LUA_HOOKDATA    6
 
 
 /*
@@ -371,6 +373,8 @@ LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
 #define LUA_MASKRET	(1 << LUA_HOOKRET)
 #define LUA_MASKLINE	(1 << LUA_HOOKLINE)
 #define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+#define LUA_MASKEDGE	(1 << LUA_HOOKEDGE)
+#define LUA_MASKDATA	(1 << LUA_HOOKDATA)
 
 typedef struct lua_Debug lua_Debug;  /* activation record */
 
@@ -410,6 +414,7 @@ struct lua_Debug {
   char isvararg;        /* (u) */
   char istailcall;	/* (t) */
   char short_src[LUA_IDSIZE]; /* (S) */
+  char *str1;	/* (C) */
   /* private part */
   struct CallInfo *i_ci;  /* active function */
 };
diff --git a/lvm.c b/lvm.c
index 657d5c45..d2c0125e 100644
--- a/lvm.c
+++ b/lvm.c
@@ -87,6 +87,28 @@ static void traceexec (lua_State *L) {
     ci->func = L->top - 1;  /* protect stack below results */
     luaD_throw(L, LUA_YIELD);
   }
+
+  Proto *p = ci_func(ci)->p;
+  OpCode opcode;
+  int npc = pcRel(ci->u.l.savedpc, p);
+  int newline = getfuncline(p, npc);
+  opcode = GET_OPCODE(*ci->u.l.savedpc);
+  if ((mask & LUA_MASKDATA) &&
+      (opcode == OP_JMP)) {
+      luaD_hook(L, LUA_HOOKDATA, newline);  /* call data hook */
+  }
+  if ((mask & LUA_MASKEDGE) &&
+      ((opcode == OP_EQ)        ||
+       (opcode == OP_LT)        ||
+       (opcode == OP_LE)        ||
+       (opcode == OP_TEST)      ||
+       (opcode == OP_TESTSET)   ||
+       (opcode == OP_CALL)      ||
+       (opcode == OP_TAILCALL)  ||
+       (opcode == OP_TFORLOOP)  ||
+       (opcode == OP_FORLOOP))) {
+      luaD_hook(L, LUA_HOOKEDGE, newline);
+  }
 }
 
 
@@ -475,7 +497,36 @@ void luaV_finishOp (lua_State *L) {
   }
 }
 
+char *trace_cmp(CallInfo *ci) {
+  Instruction i;
+  OpCode opcode;
+  LClosure *cl;
+  TValue *k, *rb;
+
+  CallInfo *nci = ci->previous;
+  i = *(nci->u.l.savedpc - 1);
+  opcode = GET_OPCODE(i);
+  printf("OPCODE: %s\n", luaP_opnames[opcode]);
+  if ((opcode != OP_EQ)  &&
+      (opcode != OP_LT)  &&
+      (opcode != OP_LE)) {
+    return NULL;
+  }
+
+  i = *(nci->u.l.savedpc - 2);
+  printf("OPCODE: %s\n", luaP_opnames[GET_OPCODE(i)]);
+  if (!(GET_OPCODE(i) == OP_LOADK))
+    return NULL;
+
+  cl = clLvalue(nci->func);  /* local reference to function's closure */
+  k = cl->p->k;              /* local reference to function's constant table */
+  rb = k + GETARG_Bx(i);
+  if (!ttisstring(rb))
+    return NULL;
 
+  /* return getstr(tsvalue(rb)); */
+  return NULL;
+}
 
 /*
 ** some macros for common tasks in `luaV_execute'
@@ -545,7 +596,7 @@ void luaV_execute (lua_State *L) {
   for (;;) {
     Instruction i = *(ci->u.l.savedpc++);
     StkId ra;
-    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT | LUA_MASKEDGE | LUA_MASKDATA)) &&
         (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
       Protect(traceexec(L));
     }
diff --git a/lvm.h b/lvm.h
index 07e25f9c..8002dd5c 100644
--- a/lvm.h
+++ b/lvm.h
@@ -25,6 +25,7 @@
 /* not to called directly */
 LUAI_FUNC int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2);
 
+char *trace_cmp(CallInfo *ci);
 
 LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
 LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
